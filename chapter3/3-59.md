typedef __int128 int128_t;<br>
void store_prod(int128_t *dest, int64_t x, int64_t y) {<br>
    *dest = x * (int128_t) y;<br>
}<br>
从提示里得知：<br>
x的128位可以重写成 xh * 2^64 + xl<br>
y的128位可以重写成 yh * 2^64 + yl<br>
那么x * y = 2^128 * xh * yh + 2^64(xh * yl + xl * yh) + xl * yl<br>
其中2^128 * xh * yh因为超过128位溢出，所以忽略<br>
剩下就是计算2^64(xh * yl + xl * yh) + xl * yl<br>
<br>
store_prod:(dest in %rdi,x in %rsi, y in %rdx)<br>
movq %rdx, %rax    &nbsp;&nbsp;&nbsp;&nbsp;     // %rax存储的是y的低64位yl <br>
cqto     &nbsp;&nbsp;&nbsp;&nbsp;               // 把y符号扩展到128位 %rdx存储y的高64位yh <br>
movq %rsi, %rcx    &nbsp;&nbsp;&nbsp;&nbsp;     // %rsi储存x的低64位xl<br>
sarq $63, %rcx     &nbsp;&nbsp;&nbsp;&nbsp;     // 把x算术右移63位,%rcx存储的相当于x的高64位xh<br>
imulq %rax, %rcx   &nbsp;&nbsp;&nbsp;&nbsp;     // yl * xh <br>
imulq %rsi, %rdx   &nbsp;&nbsp;&nbsp;&nbsp;     // xl * yh <br>
addq %rdx, %rcx    &nbsp;&nbsp;&nbsp;&nbsp;     // yl * xh + xl * yh<br>
mulq %rsi          &nbsp;&nbsp;&nbsp;&nbsp;     // xl * yl 高64: %rdx 低64: %rax<br>
addq %rcx, %rdx    &nbsp;&nbsp;&nbsp;&nbsp;     // %rcx和%rdx相加，正好就是上面公式里的2^64(xh * yl + xl * yh) + xl * yl<br>
movq %rax, (%rdi)<br>
movq %rdx, 8(%rdi)<br>
ret<br>