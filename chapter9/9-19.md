1)<br/>
a) 在一个伙伴系统中，最高可达50%的空间可以因为内部碎片而被浪费了<br/>
对，因为伙伴系统类大小是2的幂，如果是2字节的内存，我只用1字节，那么就有50%被浪费<br/>
b) 首次适配内存分配算法比最佳适配算法要慢一些（平均而言）<br/>
错，时间复杂度都是O(n),但是首次适配是前期快后期慢，最佳适配算法每次都要搜索整个堆，比首次适配更慢<br/>
c) 只有当空闲链表按照内存地址递增排序时，使用边界标记来回收才会快速<br/>
错，空闲链表按照内存地址递增排序，那么新释放的块，需要顺序遍历空闲链表，找到合适的前驱节点，反而比LIFO慢，LIFO是常数时间<br/>
d) 伙伴系统只会有内部碎片，而不会有外部碎片<br/>
错，如果申请的内存时是由小到大的申请，申请了也不释放，那么小内存块就没有办法合并成更大的内存块，那么就会产生外部碎片<br/>


2)<br/>
a) 在按照块大小递减顺序排序的空闲链表上，使用首次适配算法回导致分配性能很低，但是可以避免外部碎片<br/>
错，避免不了外部碎片，如果从小到大申请内存，那么最后大的块都被分配了，新的请求分配不到合适的块<br/>
b) 对于最佳适配方法，空闲块链表应该按照内存地址的递增顺序排序<br/>
错，内存地址递增，但是块大小随机，还是需要搜索整个空闲块链表<br/>
c) 最佳适配方法选择与请求段匹配的最大的空闲块<br/>
错，应该是选择最合适的而不是最大的<br/>
d) 在按照块大小递增的顺序排序的空闲链表上，使用首次适配算法与使用最佳适配算法等价<br/>
对，但是最佳适配算法要搜索整个空闲链表反而效率低<br/>


3) Mark&Sweep垃圾收集器在下列哪种情况下叫做保守的<br/>
a) 它们只有在内存请求不能被满足时才合并被释放的内存<br/>
否，这是提高效率的办法<br/>
b) 它们把一切看起来像指针的东西都当作指针<br/>
是<br/>
c) 它们只有内存用尽时，才执行垃圾收集<br/>
否，垃圾收集的优化<br/>
d) 它们不释放形成循环链表的内存块<br/>
否，应该属于内存泄漏<br/>