```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <resolv.h>
#include "res_internal.h"

static struct hostent *fake_hostent(const char *hostname, struct in_addr addr,
                                    struct hostent *result, char *buf,
                                    int bufsize, int *errval);
static struct hostent *file_find_name(const char *name, struct hostent *result,
                                      char *buf, int bufsize, int *errval);

struct hostent *gethostbyname(const char *hostname)
{
    struct res_data *data = _res_init();

    if (!data)
        return NULL;
    if (!data->buf) {
        data->buf = malloc(sizeof(struct hostent) + HOST_BUFSIZE);
        if (!data->buf) {
            errno = 0;
            data->errval = NO_RECOVERY;
            return NULL;
        }
    }
    return gethostbyname_r(hostname, (struct hostent *) data->buf,
                           data->buf + sizeof(struct hostent), HOST_BUFSIZE,
                           &data->errval);
}

struct hostent *gethostbyname_r(const char *hostname, struct hostent *result,
                                char *buf, int bufsize, int *errval)
{
    struct in_addr addr;
    querybuf qbuf;
    const char *p;
    int n;

    /* Default failure condition is not a range error and not recoverable. */
    errno = 0;
    *errval = NO_RECOVERY;
    
    /* Check for all-numeric hostname with no trailing dot. */
    if (isdigit(hostname[0])) {
        p = hostname;
        while (*p && (isdigit(*p) || *p == '.'))
            p++;
        if (!*p && p[-1] != '.') {
            /* Looks like an IP address; convert it. */
            if (inet_aton(hostname, &addr) == -1) {
                *errval = HOST_NOT_FOUND;
                return NULL;
            }
            return fake_hostent(hostname, addr, result, buf, bufsize, errval);
        }
    }
    
    /* Do the search. */
    n = res_search(hostname, C_IN, T_A, qbuf.buf, sizeof(qbuf));
    if (n >= 0)
        return _res_parse_answer(&qbuf, n, 0, result, buf, bufsize, errval);
    else if (errno == ECONNREFUSED)
        return file_find_name(hostname, result, buf, bufsize, errval);
    else
        return NULL;
}

static struct hostent *fake_hostent(const char *hostname, struct in_addr addr,
                                    struct hostent *result, char *buf,
                                    int bufsize, int *errval)
{
    int len = strlen(hostname);
    char *name, *addr_ptr;

    if (SP(SP(SP(buf, char, len + 1), addr, 1), char *, 3) > buf + bufsize) {
        errno = ERANGE;
        return NULL;
    }
    /*
    * 并发场景下，如果参数result传的是共享变量，hostname是两个不同的主机
    * 那么函数就会产生并发问题，所以是线程不安全的。
    *
    * 解决办法应该是在这里加互斥锁，就是本题所说的用互斥锁保护hostent结构的深层副本
    */
    /* Copy faked name and address into buffer. */
    strcpy(buf, hostname);
    name = buf;
    buf = ALIGN(buf + len + 1, addr);
    *((struct in_addr *) buf) = addr;
    addr_ptr = buf;
    buf = ALIGN(buf + sizeof(addr), char *);
    ((char **) buf)[0] = addr_ptr;
    ((char **) buf)[1] = NULL;
    ((char **) buf)[2] = NULL;

    result->h_name = name;
    result->h_aliases = ((char **) buf) + 2;
    result->h_addrtype = AF_INET;
    result->h_length = sizeof(addr);
    result->h_addr_list = (char **) buf;

    return result;
}

static struct hostent *file_find_name(const char *name, struct hostent *result,
                                      char *buf, int bufsize, int *errval)
{
    char **alias;
    FILE *fp = NULL;

    pthread_mutex_lock(&host_iterate_lock);
    sethostent(0);
    while ((result = gethostent_r(result, buf, bufsize, errval)) != NULL) {
        /* Check the entry's name and aliases against the given name. */
        if (strcasecmp(result->h_name, name) == 0)
            break;
        for (alias = result->h_aliases; *alias; alias++) {
            if (strcasecmp(*alias, name) == 0)
                break;
        }
    }
    pthread_mutex_unlock(&host_iterate_lock);
    if (!result && errno != ERANGE)
        *errval = HOST_NOT_FOUND;
    return result;
}
```