```c
/* 
 * vim proxy.conf 
 * add this:
 * backend_ip=127.0.0.1
 * backend_port=2233
 * url_filter=xxxx,yyyy
 * 
 * compile：gcc -o proxy proxy.c
 * run：./proxy ./proxy.conf
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BUF_SIZE 8192
#define DEBUG_ENABLE 1

#define DEBUG(fmt...)  if (DEBUG_ENABLE) { fprintf(stdout,"[DEBUG][%s %s] ",__DATE__,__TIME__); fprintf(stdout, ##fmt); }
#define INFO(fmt...)  do { fprintf(stdout,"[INFO][%s %s] ",__DATE__,__TIME__); fprintf(stdout, ##fmt); } while(0)
#define ERROR(fmt...)  do { fprintf(stderr,"[ERROR][%s %s] ",__DATE__,__TIME__); fprintf(stderr, ##fmt); } while(0)

char *backend_ip = NULL;
char *backend_port = NULL;
char *url_filter = NULL;

void forward_data(int source_sock, int destination_sock) {
    char buffer[BUF_SIZE];
    int n;

    while ((n = read(source_sock, buffer, BUF_SIZE)) > 0) { 

        write(destination_sock, buffer, n); 
    }
}

int readHeader(int fd, void * header_buffer)
{
    
    char line_buffer[2048];
    char *base_ptr = header_buffer;

    for(;;)
    {
        memset(line_buffer,0,2048);

        int total_read = readLine(fd,line_buffer,2048);
        if(total_read < 0) {
			ERROR("read header failed \n");
            return -1;
        }

        //防止header缓冲区越界
        if(base_ptr + total_read - header_buffer <= BUF_SIZE) {
           strncpy(base_ptr,line_buffer,total_read); 
           base_ptr += total_read;
        } else {
			ERROR("header buffer is full \n");
            return -1;
        }

        //读到了空行，http头结束
        if(strcmp(line_buffer,"\r\n") == 0 || strcmp(line_buffer,"\n") == 0) {
            break;
        }

    }
    return 1;

}

void clientHandle(int clientfd) {
	int serverfd = 0;
	struct sockaddr_in serv_addr;
    char header_buff[BUF_SIZE];
	memset(&serv_addr, 0, sizeof(serv_addr));
	// 接收header
	if (readHeader(clientfd, header_buff) < 0) {
		return;
	}
	// url黑名单过滤
	// 连接后端服务器
	DEBUG("backend ip: %s \n", backend_ip);
	DEBUG("backend port: %s \n", backend_port);

	if ((serverfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        ERROR("could not create socket \n");
        return 1;
    }

	if (connect(serverfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        ERROR("connect backend server failed \n");
        return 1;
    }

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(atoi(backend_port));
	
    if (inet_pton(AF_INET, backend_ip, &serv_addr.sin_addr) <= 0) {
        ERROR("inet_pton error occured\n");
        return 1;
    }
	// 转发header
	write(serverfd, header_buff, strlen(header_buff));
	// 转发body
	forward_data(clientfd, serverfd);
	// 转发后端服务器响应数据到客户端
	forward_data(serverfd, clientfd);
}

void start() {
	// 初始化proxy，启动监听
	int listenfd = 0, connfd = 0;
	struct sockaddr_in serv_addr;

	listenfd = socket(AF_INET, SOCK_STREAM, 0);
	memset(&serv_addr, '0', sizeof(serv_addr));

	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	serv_addr.sin_port = htons(2233);

	bind(listenfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));

	listen(listenfd, 10);
	// 循环处理客户端连接
	while (1) {
		connfd = accept(listenfd, (struct sockaddr *)NULL, NULL);
		INFO("accept client fd:%d\n", connfd);
		clientHandle(connfd);
		close(connfd);
		INFO("client exit fd:%d\n", connfd);
	}
}

size_t readLine(FILE *fp, char *buffer, size_t n) {
    size_t len = 0;
    char ch;
	for (;;) {
		ch = fgetc(fp);
		if (feof(fp)) {
			DEBUG("finish to read file\n");
			return 0;
		}
		if (ch == '\n') {
			break;
		}
		if (len > n) {
			ERROR("exceed buffer size\n");
			return -1;
		}

		buffer[len++] = ch;
	}

	buffer[len] = '\0';

    return len;
}

void loadConf(char *conf) {
	char buffer[256];
	FILE *fp = NULL;
	int ret;

	if ((fp = fopen(conf, "r")) == NULL) {
		ERROR("open %s failed\n", conf);
		exit(-1);
	}

	for (;;) {
		char *token;
		ret = readLine(fp, buffer, sizeof(buffer));
		
		if (ret < 0) {
			exit(-1);
		}

		if (ret == 0) {
			break;
		}
		
		token = strtok(buffer, "=");
		DEBUG("read config:%s\n", token);

		if (strcmp(token, "backend_ip") == 0) {
			token = strtok(NULL, "=");
			backend_ip = (char *)malloc(strlen(token) + 1);
			memcpy(backend_ip, token, strlen(token) + 1);
			DEBUG("read config:%s,size:%d\n", token,sizeof(token));

		} else if (strcmp(token, "backend_port") == 0) {
			token = strtok(NULL, "=");
			backend_port = (char *)malloc(strlen(token) + 1);
			memcpy(backend_port, token, strlen(token) + 1);
			DEBUG("read config:%s,size:%d\n", token,sizeof(token));
		}

		memset(buffer, 0, sizeof(buffer));
	}

	if (backend_ip == NULL || backend_port == NULL) {
		ERROR("parse config file failed");
		exit(-1);
	}

	fclose(fp);
}

main(int argc, char *argv[]) {
	if (argc != 2) {
		printf("Usage: %s <the file path of proxy.conf> \n", argv[0]);
		return 1;
	}
	// 读配置文件proxy.conf
	loadConf(argv[1]);
	// 启动proxy
	start();
	exit(0);
}
```
